---
defaults:
  - scope:
      path: ""
      type: posts
    values:
      layout: single
      author_profile: true
      comments: true
      share: true
      related: true

title: "[BOJ] 16234 ì¸êµ¬ ì´ë™_BFS"
excerpt: "about : python"
toc: true
toc_sticky: true
toc_label: "Label"
categories:
  - algorithm
tags:
  - BOJ
date: 2022-01-26
last_modified_at: 2022-01-26
---

# ì¸êµ¬ ì´ë™

[link](https://www.acmicpc.net/problem/16234)

## ë‚´ í’€ì´

- ë°©ì‹ : DFS, DP
- Pypy3

**ğŸ“°code**
```python
from collections import deque

N,L,R = list(map(int,input().split()))

A = []
for i in range(N):
    A += list(map(int,input().split()))

move = ((-1,0),(1,0),(0,-1),(0,1))
c = 0

while True :
    s = [[i,1] for i in A] # ì—°í•©ì˜ í•©, ì—°í•© ì§€ì—­ì˜ ìˆ˜
    a = [-1 for _ in range(N*N)] # ì—°í•© Map
    stopper = True 
    x,y = 0,0
    a[0] = 0
    q = deque()
    q.append((x,y))
    while q:
        x,y = q.popleft() # ì‹œì‘ì¢Œí‘œ, ì˜ì—­ êµ¬ë¶„
        u = a[x*N+y]
        for dx,dy in move:
            if 0<=x+dx<N and 0<=y+dy<N:
                mx,my = x+dx, y+dy
                if a[mx*N+my] == -1:
                    a[mx*N+my] = mx*N+my
                    q.append((mx,my))
                elif L<=abs(A[mx*N+my]-A[x*N+y])<=R: # ì°¨ì´ê°’ì´ L, R ì‚¬ì´ì¸ ê²½ìš°
                    stopper = False
                    if u == a[mx*N+my]:
                        continue
                    else :
                        min_u, max_u = min(a[mx*N+my],u),max(a[mx*N+my],u)
                        s[min_u][0] += s[max_u][0]
                        s[min_u][1] += s[max_u][1]
                        s[max_u] = [0,0]
                        a = [min_u if i==max_u else i for i in a]
                        q.append((mx,my))
    if stopper:
        print(c)
        break
    else : c+=1
    A = [s[i][0]//s[i][1] if s[i][1]!=0 else 0 for i in a]
```

## ë‹¤ë¥¸ í’€ì´
<br><br>

- ë°©ì‹ : DFS, DP
- 

**ğŸ“°code**
```python
from collections import deque
import sys
input = sys.stdin.readline

def bfs(c,A):
    x,y = c//N,c%N
    q = deque()
    q.append((x,y))
    popul = A[x*N+y]
    area = [x*N+y]
    while q:
        x,y = q.popleft() # ì‹œì‘ì¢Œí‘œ, ì˜ì—­ êµ¬ë¶„
        for dx,dy in move:
            if 0<=x+dx<N and 0<=y+dy<N :
                mx,my = x+dx, y+dy
                if L<=abs(A[mx*N+my]-A[x*N+y])<=R and visited[mx*N+my] != cnt:
                    visited[mx*N+my] = cnt
                    popul += A[mx*N+my]
                    area.append(mx*N+my)
                    q.append((mx,my))
    return area, popul

N,L,R = list(map(int,input().split()))

A = []
for i in range(N):
    A += list(map(int,input().split()))

move = ((-1,0),(1,0),(0,-1),(0,1))
visited = [-1 for _ in range(N*N)]
check = deque([(i) for i in range(N*N)])
cnt = 0
while True:
    for _ in range(len(check)):
        c = check.popleft()
        if visited[c] == cnt:
            continue
        visited[c] = cnt
        area,popul = bfs(c,A)
        if len(area)>1:
            popul = popul//len(area)
            for a in area:
                A[a]=popul
                check.append(a)
    if check:
        cnt +=1
    else :
        print(cnt)
        break
```

```
ğŸ’¡ ìˆ˜ì • í•„ìš”í•œ ë‚´ìš©ì€ ëŒ“ê¸€ì´ë‚˜ ë©”ì¼ë¡œ ì•Œë ¤ì£¼ì‹œë©´ ê°ì‚¬í•˜ê² ìŠµë‹ˆë‹¤!ğŸ’¡ 
```
