---
defaults:
  - scope:
      path: ""
      type: posts
    values:
      layout: single
      author_profile: true
      comments: true
      share: true
      related: true

title: "[programmers] ê°€ì‚¬ì°¾ê¸°_binary search, trie"
excerpt: "about : python"
toc: true
toc_sticky: true
toc_label: "Label"
categories:
  - algorithm
tags:
  - BOJ
date: 2022-03-18
last_modified_at: 2022-03-18
---

# ë¸”ëŸ­ ì´ë™í•˜ê¸°

[link](https://programmers.co.kr/learn/courses/30/lessons/60060)

## ë‚´ í’€ì´

- ë°©ì‹ : binary search
- ë¬¼ìŒí‘œë¥¼ ì œì™¸í•œ ë¬¸ìì—´ binary searchë¡œ ì°¾ê¸°
- pythonì—ì„œëŠ” ì—¬ëŸ¬ ë¬¸ìì—´ì— ëŒ€í•œ ë¹„êµì—°ì‚°ì‚¬ ê°€ëŠ¥í•¨
- ê°™ì€ ê¸¸ì´ì— ëŒ€í•œ sortingì€ í•œë²ˆë§Œ í•  ìˆ˜ ìˆë„ë¡ dpë¡œ êµ¬í˜„

**ğŸ“°code**

```python
from collections import defaultdict

def solution(words, queries):
    
    answer = []
    words_dict = defaultdict(list)
    words_dict_reverse = defaultdict(list)
    
    # word ê¸¸ì´ì— ë”°ë¥¸ hash table êµ¬ì„±(ì •ë°©í–¥, ë°˜ëŒ€ë°©í–¥)
    for word in words:
        words_dict[len(word)].append(word)
        words_dict_reverse[len(word)].append(word[::-1])
    
    def binary_search(arr,i,q,l,r,d):
        mid = int((l+r)/2)
        if r <= l:
            return l
        elif arr[mid][:i]<q[:i]:
            return binary_search(arr,i,q,mid+1,r,d)
        elif arr[mid][:i]>q[:i]:
            return binary_search(arr,i,q,l,mid,d)
        else : # arr[mid]==x
            if d == 'left':
                return binary_search(arr,i,q,l,mid,d)
            else : # right
                return binary_search(arr,i,q,mid+1,r,d)      
    
    def find_p(words_list,search_dir,q):
        length = len(words_list[0])
        # ë¬¼ìŒí‘œ ìœ„ì¹˜ í™•ì¸
        for i in range(length):
            if q[i] =='?': break
        left, right = 0,len(words_list)
        # ë¬¼ìŒí‘œë¥¼ ì œì™¸í•œ ë¬¸ìì—´ ë§Œí¼ binary searchë¡œ ì¢Œí‘œí™•ì¸
        left = binary_search(words_list,i,q,left, right, 'left')
        right = binary_search(words_list,i,q,left, right, 'right')
        return right - left

    # wordlist ì •ë ¬ í•œë²ˆë§Œ í•˜ë„ë¡ dp êµ¬ì„±
    dp_rev = [0]*100001
    dp = [0]*100001
    
    for q in queries:
        q_l=len(q)
        # í•´ë‹¹ ê¸¸ì´ì— ëŒ€í•œ ë‹¨ì–´ ì—†ìŒ
        if words_dict[q_l] ==[]:
            answer.append(0)
        # '?'ë¡œ ì‹œì‘í•  ê²½ìš° reverseë¡œ ì°¾ê¸°
        elif q.startswith('?'):
            search_dir = 'back'
            if dp_rev[q_l] ==0 :
                words_dict_reverse[q_l] = sorted(words_dict_reverse[q_l])
                dp_rev[q_l]=1
            words_list = words_dict_reverse[q_l]
            answer.append(find_p(words_list,search_dir,q[::-1]))
        # '?'ë¡œ ëë‚  ê²½ìš° ì •ë°©í–¥ìœ¼ë¡œ ì°¾ê¸° 
        else :
            search_dir = 'front'
            if dp[q_l] == 0 :
                words_dict[q_l] = sorted(words_dict[q_l])
                dp[q_l]=1
            words_list = words_dict[q_l]
            answer.append(find_p(words_list,search_dir,q))
    
    return answer
```
<img src="https://user-images.githubusercontent.com/77658029/158954583-a9d66bab-7bb5-4b02-9cf3-e3cdf4ed8c30.png"  width="50%" height="50%"/>

## 1íŠ¸ code _ NG

**ğŸ“°code**

```python
from collections import defaultdict

def solution(words, queries):
    
    answer = []
    words_dict = defaultdict(list)
    
    for word in words:
        words_dict[len(word)].append(word)
    
    ans_memo = defaultdict(list)
    
    def binary_search(arr,i,q,l,r,d):
        mid = int((l+r)/2)
        if r <= l:
            return l
        elif ord(arr[mid][i])<ord(q[i]): # íŒŒì´ì¬ì—ì„œëŠ” ord ì‚¬ìš©ì•ˆí•´ë„ ì—¬ëŸ¬ ë¬¸ìì—´ ë¹„êµ ê°€ëŠ¥
            return binary_search(arr,i,q,mid+1,r,d)
        elif ord(arr[mid][i])>ord(q[i]):
            return binary_search(arr,i,q,l,mid,d)
        else : # arr[mid]==x
            if d == 'left':
                return binary_search(arr,i,q,l,mid,d)
            else : # right
                return binary_search(arr,i,q,mid+1,r,d)      
    
    def find_p(words_list,search_dir,q):
        length = len(words_list[0])
        if search_dir == 'front':
            for i in range(length):
                left, right = 0,len(words_list)
                if q[i] =='?':
                    return right - left
                temp_list = sorted(words_list[left:right], key = lambda x:x[i]) #ì§€ì†ì ìœ¼ë¡œ ì •ë ¬ì´ í•„ìš”í•¨.. ì´ ë¶€ë¶„ ê°œì„  í•„ìš”
                left = binary_search(temp_list,i,q,left, right, 'left')
                right = binary_search(temp_list,i,q,left, right, 'right')
                words_list = temp_list[left:right]
        else : # search_dir == 'front':
            for i in range(length-1,-1,-1):
                left, right = 0,len(words_list)
                if q[i] =='?':
                    return right - left
                temp_list = sorted(words_list[left:right], key = lambda x:x[i])
                left = binary_search(temp_list,i,q,left, right, 'left')
                right = binary_search(temp_list,i,q,left, right, 'right')
                words_list = temp_list[left:right]
        
    for q in queries:
        if words_dict[len(q)] ==[]:
            answer.append(0)
        elif q.startswith('?'):
            search_dir = 'back'
            words_list = words_dict[len(q)]
            answer.append(find_p(words_list,search_dir,q))
        else :
            search_dir = 'front'
            words_list = words_dict[len(q)]
            answer.append(find_p(words_list,search_dir,q))
    
    return answer
```

## ë‹¤ë¥¸ ì‚¬ëŒ í’€ì´_Trie

**ğŸ“°code**

```python
class Node:
    def __init__(self, data):
        self.data = data
        self.count = 0
        self.child = {} # dictionary í˜•íƒœë¡œ Tree ìƒì„±

class Trie:
    def __init__(self):
        self.head = Node(None)

    def insert(self, string):
        cur = self.head
        cur.count += 1

        for c in string:
            if c not in cur.child:
                cur.child[c] = Node(c) # ìƒˆë¡œìš´ Nodeì— data, count, childë¡œ ì—…ë°ì´íŠ¸
            cur = cur.child[c]
            cur.count += 1

    def count(self, prefix):
        cur = self.head

        for c in prefix:
            if c not in cur.child:
                return 0
            cur = cur.child[c]

        return cur.count


def solution(words, queries):
    answer = []

    tries = create_trie(words)
    reversed_tries = create_trie(words, is_reversed = True)
    for query in queries:
        answer.append(count_matched_word(tries, reversed_tries, query))

    return answer


def create_trie(words, is_reversed = False):
    trie_dic = {i: Trie() for i in range(1, 10001)}

    for word in words:
        if is_reversed:
            word = word[::-1]
        trie_dic[len(word)].insert(word)

    return trie_dic


def count_matched_word(tries, reversed_tries, query):
    no_mark_query = query.replace('?', '')

    if query[0] == '?':
        return reversed_tries[len(query)].count(no_mark_query[::-1])
    else:
        return tries[len(query)].count(no_mark_query)
```

<img src="https://user-images.githubusercontent.com/77658029/158960775-82296d9a-3033-4300-97b5-cd02a8aed5af.png"  width="50%" height="50%"/>

```
ğŸ’¡ ìˆ˜ì • í•„ìš”í•œ ë‚´ìš©ì€ ëŒ“ê¸€ì´ë‚˜ ë©”ì¼ë¡œ ì•Œë ¤ì£¼ì‹œë©´ ê°ì‚¬í•˜ê² ìŠµë‹ˆë‹¤!ğŸ’¡ 
```
